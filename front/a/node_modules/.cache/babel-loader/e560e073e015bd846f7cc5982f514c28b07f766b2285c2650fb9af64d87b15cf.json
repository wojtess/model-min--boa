{"ast":null,"code":"import { Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useContext, useMemo } from 'react';\nimport { polarToCartesian } from './utils';\nimport Context from './context';\nconst getMarkPosition = (angle, offset, radius) => {\n  return polarToCartesian(radius, radius, radius + offset, angle);\n};\nexport default function Marks(_ref) {\n  let {\n    step = 10,\n    lineCap = 'butt',\n    lineColor = 'white',\n    lineOpacity = 1,\n    numbersRadius = 17,\n    fontSize = 18,\n    lineSize = 12,\n    children\n  } = _ref;\n  const {\n    rotation,\n    min,\n    max,\n    angle,\n    radius,\n    fontFamily\n  } = useContext(Context);\n  const marks = useMemo(() => {\n    const stepsLength = Math.round((max - min) / step);\n    const gap = angle / stepsLength;\n    return [...Array(stepsLength + 1)].map((val, index) => {\n      const actualAngle = gap * index;\n      const isEven = index % 2 == 0;\n      const size = isEven ? lineSize : lineSize - 5;\n      const {\n        x: x1,\n        y: y1\n      } = getMarkPosition(actualAngle, 0, radius);\n      const {\n        x: x2,\n        y: y2\n      } = getMarkPosition(actualAngle, -size, radius);\n      const {\n        x,\n        y\n      } = getMarkPosition(actualAngle, -lineSize - numbersRadius, radius);\n      return {\n        coordinates: {\n          x1,\n          y1,\n          x2,\n          y2\n        },\n        isEven,\n        textProps: {\n          x,\n          y,\n          transform: `rotate(${360 - rotation}, ${x}, ${y})`\n        },\n        value: Math.round(index * step + min)\n      };\n    });\n  }, [max, min, step, radius, rotation, angle, lineSize]);\n  if (children) return _jsx(_Fragment, {\n    children: marks.map(children)\n  });\n  return _jsx(_Fragment, {\n    children: marks.map((mark, i) => _jsxs(\"g\", {\n      children: [_jsx(\"line\", {\n        ...mark.coordinates,\n        stroke: lineColor,\n        strokeWidth: mark.isEven ? 3 : 2,\n        strokeOpacity: lineOpacity,\n        strokeLinecap: lineCap\n      }), mark.isEven && _jsx(\"text\", {\n        ...mark.textProps,\n        fill: \"white\",\n        textAnchor: \"middle\",\n        alignmentBaseline: \"middle\",\n        fontFamily: fontFamily,\n        opacity: 0.8,\n        fontSize: fontSize,\n        children: mark.value\n      })]\n    }, i))\n  });\n}","map":{"version":3,"names":["Fragment","_Fragment","jsx","_jsx","jsxs","_jsxs","useContext","useMemo","polarToCartesian","Context","getMarkPosition","angle","offset","radius","Marks","_ref","step","lineCap","lineColor","lineOpacity","numbersRadius","fontSize","lineSize","children","rotation","min","max","fontFamily","marks","stepsLength","Math","round","gap","Array","map","val","index","actualAngle","isEven","size","x","x1","y","y1","x2","y2","coordinates","textProps","transform","value","mark","i","stroke","strokeWidth","strokeOpacity","strokeLinecap","fill","textAnchor","alignmentBaseline","opacity"],"sources":["/home/jedrek/Powertrain/miniboat-website/node_modules/react-speedometer/dist/Marks.js"],"sourcesContent":["import { Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { useContext, useMemo } from 'react';\nimport { polarToCartesian } from './utils';\nimport Context from './context';\nconst getMarkPosition = (angle, offset, radius) => {\n    return polarToCartesian(radius, radius, radius + offset, angle);\n};\nexport default function Marks({ step = 10, lineCap = 'butt', lineColor = 'white', lineOpacity = 1, numbersRadius = 17, fontSize = 18, lineSize = 12, children, }) {\n    const { rotation, min, max, angle, radius, fontFamily } = useContext(Context);\n    const marks = useMemo(() => {\n        const stepsLength = Math.round((max - min) / step);\n        const gap = angle / stepsLength;\n        return [...Array(stepsLength + 1)].map((val, index) => {\n            const actualAngle = gap * index;\n            const isEven = index % 2 == 0;\n            const size = isEven ? lineSize : lineSize - 5;\n            const { x: x1, y: y1 } = getMarkPosition(actualAngle, 0, radius);\n            const { x: x2, y: y2 } = getMarkPosition(actualAngle, -size, radius);\n            const { x, y } = getMarkPosition(actualAngle, -lineSize - numbersRadius, radius);\n            return {\n                coordinates: { x1, y1, x2, y2 },\n                isEven,\n                textProps: { x, y, transform: `rotate(${360 - rotation}, ${x}, ${y})` },\n                value: Math.round((index * step) + min)\n            };\n        });\n    }, [max, min, step, radius, rotation, angle, lineSize]);\n    if (children)\n        return (_jsx(_Fragment, { children: marks.map(children) }));\n    return (_jsx(_Fragment, { children: marks.map((mark, i) => (_jsxs(\"g\", { children: [_jsx(\"line\", { ...mark.coordinates, stroke: lineColor, strokeWidth: mark.isEven ? 3 : 2, strokeOpacity: lineOpacity, strokeLinecap: lineCap }), mark.isEven && (_jsx(\"text\", { ...mark.textProps, fill: \"white\", textAnchor: \"middle\", alignmentBaseline: \"middle\", fontFamily: fontFamily, opacity: 0.8, fontSize: fontSize, children: mark.value }))] }, i))) }));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}